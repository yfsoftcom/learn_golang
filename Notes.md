## Notes For Interview

### Golang
- GPM
  - M(Machine): 一个内核线程，由Go的调度器进行管理，G运行在M上
  - P(Processer): 一个逻辑处理器，调度器将其绑定了一个本地的routine队列，其主要职责就是读取可执行的routine，并执行它，其占用了一个CPU线程的资源
  - G(Goroutine): 一个运行中的routine，每个g都会有自己的内存和状态，通常一个P同一时间只会允许1个G运行

  #### CPU线程和内核线程的区别
  - 内核线程可以成千上万，但是CPU线程只和CPU的数量有关

  #### runtime主要做哪些工作？
  - 初始化P
  - 运行G0进行调度
    - 会运行一个线程监控全局的G的执行状态
  - 执行M0进行具体的工作

  #### 进程启动的详细过程？
  - 初始化固定数量的P，放入到一个P的链表中，等待M进行绑定
  - 运行一个G运行runtime.main
  - 创建M0，G0进行调度循环，等待G被创建并绑定P
  - 新创建的G会被优先放到P的等待队列中被调度，然后被切换到P上执行

  #### 主动让出CPU的几种途径？非抢占式调度
  - time.Sleep()
  - channel
  - sync.Mutex()
  - system.Call()

  Go使用非抢占式的调度模型，即G休眠只是被标记Gwaiting的状态， 待其恢复了，则将其标记为Grunning的状态，放入到队列中。

  #### 内存逃逸？从哪到哪了？哪些情况下会发生
  - 编译器无法确定该给程序分配多大内存的时候会出现内存逃逸。
  - 从栈空间逃逸到堆空间
    - 切片中包含大量的指针数据时
    - 接口调用时
    - channel中传递指针时
    - 等等

  #### 其他相关概念
  - 全局routine队列
    - 在本地队列无法容纳的g时存放，由P进行有条件的读取
      - 当P处于空闲状态，即本地队列被清空的情况下，会从全局队列中抓取一半到本地执行
      - 非空闲状态下的P会有一定的概率（1/61）从全局中获取到g进行执行
  - 本地routine队列
    - 程序运行之初，调度器会平均分配routine到各个P的Local队列中，该队列有一个上限（默认是255），超出的话，会放入到全局的队列中
    - 空闲中的P会从其他不空闲中的P中偷取一部分g执行
  - 如果G中的任务发生了阻塞了，GPM会发生什么变化
    - 用户态的阻塞：
      - 比如wait/chan等
      - [TODO] 该g会被标记为阻塞状态，P会跳过该g，执行后续的任务，直到该g完成之后被唤醒。
    - 系统级的阻塞：
      - P会剥离出去，原先的MG会等待g执行完成再放到P的队列中
      - go调度器会创建一个新的MG来绑定这个P
      - g执行完了之后，原有的M会暂存，供之后调用
  - 如果g执行了一个网络I/O阻塞，会发生什么？
    - g被分离之后，会放到带有网络轮询器的routine中进行执行（可能就是epoll）

  #### Reference
  - https://mp.weixin.qq.com/s/_ujmGibYT3s61dBkIIeayw
- GC
  - 实现模型？
    #### 使用3色标记法进行GC
    1) 首先将所有的对象标记为White；
    2) 从根内存进行Scan 将能访问到的对象标记为灰色，并放入到队列；
    3) 扫描灰色队列中的对象，找到引用它的所有的对象，并标记为灰色，并放入到队列；
    4) 重复3，直到队列中所有的对象都被扫描过，将该队列中的对象全部标记成黑色，然后把所有被标记成白色的对象进行清理；

  - 何时触发？
    
  - 能否手动执行？
    - 可以手动触发，如果手动触发的，则该GCroutine是阻塞的，使用 `runtime.GC()` 进行手动触发；
    - 
  - SWT
  - write barrier 的作用

  #### Reference
  - https://liujiacai.net/blog/2018/08/04/incremental-gc/
- reflect

- channel
  #### 发送者
  - 检查有没有##等待中##(意思就是有空闲的接受者，因此可以判定该通道已经空了)的接受者等待接收
    - 如果有，直接发送给接受者，然后继续执行当前的g
    - 如果没有，则尝试将数据存储到chan的临时区
      - 如果chan已经满了，则将当前的g挂起，放到runq队列中，等待被读取时唤醒
      - 如果chan没有满，将数据copy到chan的临时区进行存储，继续当前的g

  #### 接受者
  - 如发送者休眠，则唤起发送者，然后将数据读取过来
  - 如果没有休眠者，则从chan的开头部分取出数据（以保证按照顺序进行）
  - 如果两者都没有，则会标记当前的g挂起，等待发送者唤醒

  #### reference
  - https://speakerdeck.com/kavya719/understanding-channels?slide=87

- defer
  - 符合FILO的规则，最先压入的会最后执行
  - defer 后的语句虽然不会立刻执行，但会被立即计算
  - painic 并不会阻止 defer 的执行
- slice/array
  - 没有定义明确数量的数组即是切片
  - slice是一个内置的数据结构，只有24个字节，本身指向一个底层的数组，因此在进行值传递时，产生copy也不会有太多的资源消耗
  - slice的长度和容量是可以进行动态调整的，使用append函数可以增加容量，容量不够时会自动扩展一倍的空间，在 len <1000 时，否则，默认扩充到1.25倍。
  - slice切割之后，其指向的原始数组地址不会改变，所以数据被修改了之后，其他引用到的地方也会感知到，可能出现bug。
- make/new
  - `make()` 只能作用于3中内置的数据类型进行初始化，包含 `slice` / `map` / `chan` 3中数据类型；
    对应的返回值分别对应 `runtime.hslice` / `runtime.hhash` / `runtime.hchan` 3种类型；
    其中 `runtime.hslice` 是结构体， 其他的是指针类型。
  - `new()` 接受一个数据类型，返回其实例的指针引用。
- sync.Map

- init
  - 该方法是隐藏函数，优先与main函数执行，根据包的引用关系和文件名的顺序依次执行。如果包没有被引用，则不会被执行。

### Computer

- Process/Thread/Routine

- 用户态/内核态

- select / epoll

### Network

- TCP/UDP
  - 两者都是基于TCP/IP协议的传输层，可以在不同的设备之间传输数据
  - TCP：需要两者建立连接之后才能传输数据，数据的顺序和完整性都是可以保证的，因为会使用3次握手和4次挥手，存在重发机制，数据包头会有20Bytes的数据，用于标记数据的详细信息。
  - UDP：类似于广播的性质，传输者只需要将数据传输到网络中，接受者自己获取包数据，因为不需要双方确认信息，所以传输速度快，资源消耗小，但是数据的顺序和完整性都无法保障；其数据包头只使用了8Bytes的空间来标记数据。
  - TCP：适用于 HTTP/SMTP/FTP 等。
  - UPD：适合视频/语音通话，直播广播，DNS，DHCP等
  - 具体的数据包头信息：
    - TCP：源端口，目标端口，序列号，应答号，数据长度，数据检验码
    - UDP：源端口，目标端口，数据长度，数据校验码

- grpc/http/http2.0

- keep alive

### Data Struct


### Algorithm(算法)

##### Bloom Filter（布龙过滤器）

##### 一致性哈希
- 不一致会导致什么问题？
  - 分布式缓存场景下，减少/增加节点会使缓存失效，同时的大量失效会导致“缓存雪崩”的情况，对业务造成影响。
  - 传统哈希算法在定位节点的时候，会根据可用的节点数量取莫来定位，节点数量的变化，会使之前计算出来的映射关系发生偏移，导致缓存失效。

- 如何解决？
  - 采用《一致性哈希》（Consisting Hash）算法进行弥补
    - 将哈希定义为一个环形图（0～2^32）hash为一个`uint32`数据
    - 将所有的缓存节点hash之后定位到hash环上
    - 数据key被hash之后，按照顺时针的方向，定位到位于其hash值下一个缓存节点上
    - 该算法并不能完全解决缓存雪崩的问题，只能尽量在最小程度上减小对业务的实际影响

- 如何解决分布不均匀的问题？
  - 增加虚拟节点的方式，将虚拟节点定位到hash环上
  - 数据和虚拟节点对应
  - 虚拟节点和真实节点对应

##### https 握手过程？

### Mysql

##### 索引相关

###### mysql在什么情况下会认为全表扫描的效率会高于索引搜索的效率，为什么？

##### SQL优化

##### 数据量大之后如何优化
- 如何高效的删除一张大表
- 如何在不影响业务的情况下，给一个表建立一个索引

##### 事务隔离级别

##### 脏读/幻读/不可重复度等问题

##### 主从同步延迟问题如何解决

##### 锁相关问题

### Redis

##### 常用数据类型

##### 内部的数据结构

##### 数据淘汰的算法

### InfluxDB

##### 为什么可以高效的存储时序数据？

- 将数据按照时间区间分成若干的区块存储
- 自动存储策略可以定期回收过期的数据
- 有效的数据会存放在内存中
- 启动之后会将 wal 中的数据加载到内存中
- 通过索引快速查询数据

##### 主要的架构设计是什么？

##### 引擎 TSM


##### 索引采用什么数据结构？

##### Ref
- https://blog.fatedier.com/2016/08/05/detailed-in-influxdb-tsm-storage-engine-one/


### Docker

- docker 原理

- docker网络，如何分配ip

- docker如何优化一个Dockerfile使其减少构建时间

- docker 和传统的 VM 的区别

### K8S

- 如何实现选主的

- 如何实现容器之间跨机器相互访问的

- Ingress 实现了什么，有什么作用

- 如何灰度发布

- 如何创建存储

- 如何感知服务的状态

- 如何使用k8s中的插件