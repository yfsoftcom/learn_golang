## GPM Modal

[https://zboya.github.io/post/go_scheduler/](https://zboya.github.io/post/go_scheduler/)


#### g0 & m0

首先要明确的是每个m都有一个g0，因为每个线程有一个系统堆栈，g0 虽然也是g的结构，但和普通的g还是有差别的，最重要的差别就是栈的差别。g0 上的栈是系统分配的栈，在linux上栈大小默认固定8MB，不能扩展，也不能缩小。 而普通g一开始只有2KB大小，可扩展。在 g0 上也没有任何任务函数，也没有任何状态，并且它不能被调度程序抢占。因为调度就是在g0上跑的。


#### 复用线程

goroutines本身就是运行在一组线程之上，不需要频繁的创建、销毁线程，而是对线程的复用。在调度器中复用线程还有2个体现：  
1. work stealing，当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。   
2. hand off，当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。  

#### 调度器基本策略

全局G队列 在调度器中有全局G队列，用来均衡每个P上面G的数量。
一定的抢占 当一个goroutine占用cpu超过10ms，会被抢占，防止其他goroutine饿死。